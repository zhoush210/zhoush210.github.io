---
layout: post
title:  "C++ Primer：C++标准库"
subtitle: "第二部分"
date:   2023-2-24 10:03:00 +0800
author:     "ZhouSh"
header-img: "img/bg-guidao9.jpg"
header-mask: 0.2
tags:
    - C++
---
## 八、IO库

**IO对象不能拷贝或赋值**，所以不能将形参或返回类型设置为IO类型，进行IO操作的函数通常以**引用**方式传递和返回流。

文本串可能立即打印出来，但也可能被操作系统保存在缓冲区中，随后再打印。如下代码将先等待3s再打印aaabbb，而不是立即打印aaa再等待3s。
```
#include <iostream>
#include <chrono>
#include <thread>

int main(){
    std::cout << "aaa";
    std::this_thread::sleep_for(std::chrono::seconds(3));
    std::cout << "bbb";
}
```

操作符**endl**换行并刷新缓冲区，**flush**刷新缓冲区但不输出任何额外字符，**ends**向缓冲区插入一个空字符再刷新缓冲区。

默认情况下，对**cerr**是设置unitbuf的，因此写到cerr的内容都是立即刷新的。

**unitbuf**操作符告诉流在接下来的每次写操作后都进行一次flush操作。而**nounitbuf**则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制。

默认情况下，cin和cerr都关联到cout，因此读cin或写cerr都会导致cout的缓冲区被刷新。

如果程序异常终止，输出缓冲区不会被刷新，数据很可能停留在缓冲区中等待打印。所以调试程序时最好在输出语句后都跟上endl。

## 九、顺序容器

标准库中的顺序容器：
<img src="/img/in_post/Cpp-Primer/4.png" width="100%">

**string和vector将元素保存在连续的内存空间中**。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。但是，在这两种容器的中间位置添加或删除元素就会非常耗时。

**list和forward_list**两个容器的设计目的是令**容器任何位置的添加和删除操作都很快速**。作为代价，这两个容器**不支持元素的随机访问**：为了访问一个元素，我们只能遍历整个容器。

与内置数组相比，**array**是一种更安全、更容易使用的数组类型。

通常，使用vector是最好的选择，除非你有很好的理由选择其他容器。

如果必须在中间位置插入元素，考虑在输入阶段使用list，一旦输入完成，将list中的内容拷贝到一个vector中。

如果你不确定应该使用哪种容器，那么可以在程序中只使用vector和list公共的操作：**使用迭代器**，不使用下标操作，避免随机访问。这样，在必要时选择使用vector或list都很方便。

与内置数组一样，标准库array的大小也是类型的一部分。当定义一个array时，除了指定元素类型，还要指定容器大小。

不能对内置数组类型进行**拷贝**或**对象赋值**操作，但**array**并无此限制

assign操作用参数所指定的元素（的拷贝）替换左边容器中的所有元素。这段代码中对assign的调用将names中的元素替换为迭代器指定的范围中的元素的拷贝。
```
list<string> names;
vector<const char*> oldstyle;
names.assign(oldstyle.cbegin(), oldstyle.cend());
```

swap操作交换两个相同类型容器的内容。调用swap之后，两个容器中的元素将会交换,svec1将包含24个string元素，svec2将包含10个string。除array外，交换两个容器内容的操作保证会很快——元素本身并未交换，swap只是交换了两个容器的内部数据结构。
```
vector<string> svec1(10);
vector<string> svec2(24);
swap(svec1, svec2);
```

与其他容器不同，对一个**string**调用**swap**会导致**迭代器、引用和指针失效**。

与其他容器不同，**swap**两个**array**会真正交换它们的元素。
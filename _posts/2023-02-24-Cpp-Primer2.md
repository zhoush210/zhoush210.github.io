---
layout: post
title:  "C++ Primer：C++标准库"
subtitle: "第二部分"
date:   2023-2-24 10:03:00 +0800
author:     "ZhouSh"
header-img: "img/bg-guidao9.jpg"
header-mask: 0.2
tags:
    - C++
---
## 八、IO库

**IO对象不能拷贝或赋值**，所以不能将形参或返回类型设置为IO类型，进行IO操作的函数通常以**引用**方式传递和返回流。

文本串可能立即打印出来，但也可能被操作系统保存在缓冲区中，随后再打印。如下代码将先等待3s再打印aaabbb，而不是立即打印aaa再等待3s。
```
#include <iostream>
#include <chrono>
#include <thread>

int main(){
    std::cout << "aaa";
    std::this_thread::sleep_for(std::chrono::seconds(3));
    std::cout << "bbb";
}
```

操作符**endl**换行并刷新缓冲区，**flush**刷新缓冲区但不输出任何额外字符，**ends**向缓冲区插入一个空字符再刷新缓冲区。

默认情况下，对**cerr**是设置unitbuf的，因此写到cerr的内容都是立即刷新的。

**unitbuf**操作符告诉流在接下来的每次写操作后都进行一次flush操作。而**nounitbuf**则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制。

默认情况下，cin和cerr都关联到cout，因此读cin或写cerr都会导致cout的缓冲区被刷新。

如果程序异常终止，输出缓冲区不会被刷新，数据很可能停留在缓冲区中等待打印。所以调试程序时最好在输出语句后都跟上endl。

## 九、顺序容器

标准库中的顺序容器：
<img src="/img/in_post/Cpp-Primer/4.png" width="100%">

**string和vector将元素保存在连续的内存空间中**。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。但是，在这两种容器的中间位置添加或删除元素就会非常耗时。

**list和forward_list**两个容器的设计目的是令**容器任何位置的添加和删除操作都很快速**。作为代价，这两个容器**不支持元素的随机访问**：为了访问一个元素，我们只能遍历整个容器。

与内置数组相比，**array**是一种更安全、更容易使用的数组类型。

通常，使用vector是最好的选择，除非你有很好的理由选择其他容器。

如果必须在中间位置插入元素，考虑在输入阶段使用list，一旦输入完成，将list中的内容拷贝到一个vector中。

如果你不确定应该使用哪种容器，那么可以在程序中只使用vector和list公共的操作：**使用迭代器**，不使用下标操作，避免随机访问。这样，在必要时选择使用vector或list都很方便。